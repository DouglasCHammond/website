---
title: "CPS 230 Lecture 17"
---

# Lecture 17: Linking

Linking is a task in which multiple binary object files (either generated by an assembler or compiler) are stiched together to form an executable.  The linker has two main jobs, symbol discovery and relocation.  Throughout this semester, most assembly files we've written have relied on one of two functions that are not specified in the assembly file, printf and scanf.  These are actually specified in the legacy_stdio_definitions.lib file that we have been including in the cl command. 

When files are linked, they are passed to the linker in an order.  We've been using `assembly_file.obj msvcrt.lib legacy_stdio_definitions.lib` so far. What happens is the .text and .data for each obj or lib file are split apart, and then rearranged so that all .text sections come before .data sections in the final executable.  In other words the final executable generated from `assembly_file.obj msvcrt.lib legacy_stdio_definitions.lib` would have the folowing order:

* assembly_file.obj .text section
* msvcrt.lib .text section
* legacy_stdio_definitions.lib .text section
* assembly_file.obj .data section
* msvcrt.lib .data section
* legacy_stdio_definitions.lib .data section

I find that the linking process is easier to follow if we have a real example, so here are two assembly files that we are going to merge. 

``` asm
; ape.asm
extern _rasp
extern golf_cart

section .text
    int3
    int3
    int3
    int3
    int3

global _saw
_saw:
    mov eax, [banana]
    xor eax, [golf_cart]
    ret

    int3
    int3

global _tape_measure
_tape_measure:
    mov eax, [golf_cart]
    add eax, [plum]
    ret


section .data
plum  dd  0x39d
banana  dd  _rasp
```

``` asm
; insect.asm
extern _saw
extern _tape_measure

section .text
    int3

global _rasp
_rasp:
    push    ebp
    mov     ebp, esp

    push    dword [helicopter]
    call    _saw
    add     esp, 4

    pop     ebp
    ret

section .data
    db 0,0,0,0
helicopter  dd  0x258
    db 0,0,0,0,0,0
global golf_cart
golf_cart  dd  0x258
```

Now, we'll begin walking through the steps required in order to link.  In the end, if everything is correct, our executable binary will have the md5 hash `905230137a7b85142d7331f126f2c09d`.

## Symbol Location

Symobols for our purposes represent anything included from another obj file (using the `extern` command) or anything made available to another obj file (using the `global` command).  So if look at ape.asm, there are 4 symbols: \_rasp, golf_cart, \_saw, and \_tape_measure.  We also need (for later purposes) to calculate the offsets of these symbols as well as record the section they occurred in, the offset being the byte position that a symbol occurs in the binary representation. Note: extern symbols always have an offset of 0 with a section of extern.

Using the previously mentioned counting scheme, we get the following values for each file.

### ape.asm Symbols

| symbol | offset | location |
| --- | --- | --- |
| \_rasp | 0 | extern | 
| \_golf_cart | 0 | extern | 
| \_saw | 5 | ape.text | 
| \_tape_measure | 19 | ape.text | 

### insect.asm Symbols

| symbol | offset | location |
| --- | --- | --- |
| \_saw | 0 | extern |
| \_tape_measure | 0 | extern |
| \_rasp | 1 | insect.text |
| golf_cart | 14 | insect.data |

For the final symbol, remember that dd represents 4 bytes.

## Relocation Needs

There also a couple of symbols that we need to relocate.  For example, both files have references for items in other files.  Also, some .text sections have references to .data sections (remember, they will get split up at some point).  There are two types of relocations (which have differing calculation formulas) Direct (DIR32) and Relative (REL32).  For our purposes, REL32 only happens if the relocation is associated with a call.

### ape.asm .text relocations

| target | offset | kind |
| --- | --- | --- |
| ape.data | 6 | DIR32 |
| golf_cart | 12 | DIR32 |
| golf_cart | 20 | DIR32 |
| ape.data | 26 | DIR32 |

### ape.asm .data relocations

| target | offset | kind |
| --- | --- | --- |
| \_rasp | 4 | DIR32 |

### insect.asm .text relocations

| target | offset | kind |
| --- | --- | --- |
| insect.data | 6 | DIR32 |
| \_saw | 11 | REL32 |

### insect.asm .data relocations

(none)

## Relocating

First things first, we'll need an address (the address where the exe will reside in memory) to complete this task all the way.  We'll assume `0x3987800` is the address for this program.  There are two tables that we'll need to complete this task.  This first is the section summary table and the second is the symbol summary table.

We're also going to need the binary represetation of each section:

``` asm
; ape.asm .text
00000000: CC CC CC CC CC A1 04 00  00 00 33 05 00 00 00 00  ..........3.....
00000010: C3 CC CC A1 00 00 00 00  03 05 00 00 00 00 C3     ...............
```

``` asm
; ape.asm .data
00000000: 9D 03 00 00 00 00 00 00                           ........
```

``` asm
; insect.asm .text
00000000: CC 55 89 E5 FF 35 04 00  00 00 E8 00 00 00 00 83  .U...5..........
00000010: C4 04 5D C3                                       ..].
```

``` asm
; insect.asm .data
00000000: 00 00 00 00 58 02 00 00  00 00 00 00 00 00 58 02  ....X.........X.
00000010: 00 00                                             ..
```

### Section Summary Table

Linkers often pad each section (before concatenation) with 0s so that it is a multiple of the memory base size.  This helps with speed as well as preserving sanity in determining offsets.  In our case, we'll assume that each section is padded so that is a multiple of 16.

| section | offset | memory address |
| --- | --- | --- |
| ape.text | 0 | 0x3987800 |
| insect.text | 32 | 0x3987820 |
| ape.data | 64 | 0x3987840 |
| insect.data | 80 | 0x3987850 |

### Symbol Summary Table

The memory address of each section helps us determine what the memory address of each symbol should be (whose offset is from the start of the section).  Note: extern symbols do not count here.

| symbol | from | offset | memory address |
| --- | --- | --- | --- |
| \_saw | ape.text | 5 | 0x3987805 | 
| \_tape_measure | ape.text | 19 | 0x3987813 | 
| \_rasp | insect.text | 1 | 0x3987821 |
| golf_cart | insect.data | 14 | 0x398785E |

Finally, we have enough information to generate the relocation summary table.

### Relocation Summary Table

This step is the hardest, but it is the last step before we can generate our final executable.  We need to take all of the items that need relocations and do the relocation.  Each entry in the table has multiple fields:

* section: where the relocation is located
* offset: the offset of relocation in the section
* site: the address of the relocation (using the loaded memory address) [= section address + offset]
* target: the target of the relocation
* value: the value currently in site (4 bytes)
* adjusted value: the value to copied into site (calculation depends on type)

For DIR32, the adjusted value is simple the target address + the value.  For REL32, the adjusted value is the target address - (site address + 4) + 1.

| section | offset | site | target | kind | value | adjusted value |
| --- | --- | --- | --- | --- | --- | --- |
| ape.text | 6 | 0x3987806 | DIR32 | ape.data | 0x4 | 0x3987844 |
| ape.text | 12 | 0x398780C | DIR32 | golf_cart | 0x0 | 0x398785E |
| ape.text | 20 | 0x3987814 | DIR32 | golf_cart | 0x0 | 0x398785E |
| ape.text | 26 | 0x398781A | DIR32 | ape.data | 0x0 | 0x3987840 |
| insect.text | 6 | 0x3987826 | DIR32 | insect.data | 0x4 | 0x3987854 |
| insect.text | 11 | 0x398782B  | REL32 | \_saw | 0x0 | 0xffffffd6 |
| ape.data | 4 | 0x3987844 | DIR32 | \_rasp | 0x0 | 0x3987821 |

Finally, we have enough to generate the final image.

### Final Image Generation

First, concatenate all of the sections together (in the right order with padding):

``` asm
3987800: CC CC CC CC CC A1 04 00  00 00 33 05 00 00 00 00
3987810: C3 CC CC A1 00 00 00 00  03 05 00 00 00 00 C3 00
3987820: CC 55 89 E5 FF 35 04 00  00 00 E8 00 00 00 00 83
3987830: C4 04 5D C3 00 00 00 00  00 00 00 00 00 00 00 00
3987840: 9D 03 00 00 00 00 00 00  00 00 00 00 00 00 00 00
3987850: 00 00 00 00 58 02 00 00  00 00 00 00 00 00 58 02
3987860: 00 00
```

Now, for each entry in the relocation table, enter the adjusted value into the site address (in little endian).

``` asm
3987800: CC CC CC CC CC A1 44 78  98 03 33 05 5E 78 98 03
3987810: C3 CC CC A1 5E 78 98 03  03 05 40 78 98 03 C3 00
3987820: CC 55 89 E5 FF 35 54 78  98 03 E8 D6 FF FF FF 83
3987830: C4 04 5D C3 00 00 00 00  00 00 00 00 00 00 00 00
3987840: 9D 03 00 00 21 78 98 03  00 00 00 00 00 00 00 00
3987850: 00 00 00 00 58 02 00 00  00 00 00 00 00 00 58 02
3987860: 00 00
```

Now, we just simply load this file into a hex editor and check its md5 sum using [Online MD5](http://onlinemd5.com). The result value is `905230137a7b85142d7331f126f2c09d` which matches `905230137a7b85142d7331f126f2c09d`.
