---
title: "CPS 230"
date: 2018-08-21T00:00:00-04:00
draft: false
---

# Lecture 17: Linking

Linking is a task in which multiple binary object files (either generated by an assembler or compiler) are stiched together to form an executable.  The linker has two main jobs, symbol discovery and relocation.  Throughout this semester, most assembly files we've written have relied on one of two functions that are not specified in the assembly file, printf and scanf.  These are actually specified in the legacy_stdio_definitions.lib file that we have been including in the cl command. 

When files are linked, they are passed to the linker in an order.  We've been using `assembly_file.obj msvcrt.lib legacy_stdio_definitions.lib` so far. What happens is the .text and .data for each obj or lib file are split apart, and then rearranged so that all .text sections come before .data sections in the final executable.  In other words the final executable generated from `assembly_file.obj msvcrt.lib legacy_stdio_definitions.lib` would have the folowing order:

* assembly_file.obj .text section
* msvcrt.lib .text section
* legacy_stdio_definitions.lib .text section
* assembly_file.obj .data section
* msvcrt.lib .data section
* legacy_stdio_definitions.lib .data section

I find that the linking process is easier to follow if we have a real example, so here are two assembly files that we are going to merge. 

``` asm
; ape.asm
extern _chisel
extern _level

section .text
    int3
    int3
    int3
    int3
    int3

global _saw
_saw:
    push    rbp
    mov     rbp, rsp

    mov     rcx, [automobile]
    call    _chisel

    pop     rbp
    ret

section .data
    db 0,0,0,0
automobile  dq  0x271
    db 0,0,0,0,0,0
global bicycle
bicycle  dq  0x1c2
```

``` asm
; insect.asm
extern _saw
extern bicycle

section .text
    int3

global _chisel
_chisel:
    mov rax, [apple]
    xor rax, [bicycle]
    ret

    int3

global _level
_level:
    mov rax, [bicycle]
    add rax, [plum]
    ret


section .data
plum  dq  0x307
apple  dq  _saw
```

Now, we'll begin walking through the steps required in order to link.  In the end, if everything is correct, our executable binary will have the md5 hash `a5e19066db8bc53df26f85a19bca063c`.

## Symbol Location

Symobols for our purposes represent anything included from another obj file (using the `extern` command) or anything made available to another obj file (using the `global` command).  So if you look at ape.asm, there are 4 symbols: \_rasp, golf_cart, \_saw, and \_tape_measure.  The obj file generated by the linker gives us the offset of each symbol within the file.

### ape.asm Symbols

| symbol | offset | location |
| --- | --- | --- |
| _chisel | 0 | extern | 
| _level | 0 | extern | 
| _saw | 5 | ape.text | 
| bicycle | 18 | ape.data | 

### insect.asm Symbols

| symbol | offset | location |
| --- | --- | --- |
| _saw | 0 | extern |
| bicycle | 0 | extern |
| _chisel | 1 | insect.text |
| _level | 19 | insect.text |

For the final symbol, remember that dq represents 8 bytes.

## Relocation Needs

There also a couple of symbols that we need to relocate.  For example, both files have references for items in other files.  Also, some .text sections have references to .data sections (remember, they will get split up at some point).  There are two types of relocations (which have differing calculation formulas) Direct (ADDR32 / ADDR64) and Relative (REL32).  For our purposes, REL32 only happens if the relocation is associated with a call.  Once again, the linker gives us the offsets of each relocation.

What's with the 32 stuff? I thought we were writing 64-bit!  We are, but nasm automatically translates some stuff, especially addresses to 32-bit instead because the 32-bit instructions are an order of magnitude faster.

### ape.asm .text relocations

| target | offset | kind |
| --- | --- | --- |
| ape.data | 13 | ADDR32 |
| _chisel | 18 | REL32 |

### ape.asm .data relocations

(none)

### insect.asm .text relocations

| target | offset | kind |
| --- | --- | --- |
| insect.data | 5 | ADDR32 |
| bicycle | 13 | ADDR32 |
| bicycle | 23 | ADDR32 |
| insect.data | 31 | ADDR32 |

### insect.asm .data relocations

| target | offset | kind |
| --- | --- | --- |
| _saw | 8 | ADDR64 |

## Relocating

First things first, we'll need an address (the address where the exe will reside in memory) to complete this task all the way.  We'll assume `0xc91f000` is the address for this program.  There are two tables that we'll need to complete this task.  This first is the section summary table and the second is the symbol summary table.

We're also going to need the binary represetation of each section:

``` asm
; ape.asm .text
00000000: CC CC CC CC CC 55 48 89  E5 48 8B 0C 25 04 00 00
00000010: 00 E8 00 00 00 00 5D C3
```

``` asm
; ape.asm .data
00000000: 00 00 00 00 71 02 00 00  00 00 00 00 00 00 00 00
00000010: 00 00 C2 01 00 00 00 00  00 00
```

``` asm
; insect.asm .text
00000000: CC 48 8B 04 25 08 00 00  00 48 33 04 25 00 00 00
00000010: 00 C3 CC 48 8B 04 25 00  00 00 00 48 03 04 25 00
00000020: 00 00 00 C3
```

``` asm
; insect.asm .data
00000000: 07 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

### Section Summary Table

Linkers often pad each section (before concatenation) with 0s so that it is a multiple of the memory base size.  This helps with speed as well as preserving sanity in determining offsets.  In our case, we'll assume that each section is padded so that is a multiple of 16.

| section | offset | memory address |
| --- | --- | --- |
| ape.text | 0 | 0xc91f000 |
| insect.text | 32 | 0xc91f020 |
| ape.data | 80 | 0xc91f050 |
| insect.data | 112 | 0xc91f070 |

### Symbol Summary Table

The memory address of each section helps us determine what the memory address of each symbol should be (whose offset is from the start of the section).  Note: extern symbols do not count here.

| symbol | from | offset | memory address |
| --- | --- | --- | --- |
| _saw | ape.text | 5 | 0xc91f005 | 
| bicycle | ape.data | 18 | 0xc91f062 | 
| _chisel | insect.text | 1 | 0xc91f021 |
| _level | insect.text | 19 | 0xc91f033 |

Finally, we have enough information to generate the relocation summary table.

### Relocation Summary Table

This step is the hardest, but it is the last step before we can generate our final executable.  We need to take all of the items that need relocations and do the relocation.  Each entry in the table has multiple fields:

* section: where the relocation is located
* offset: the offset of relocation in the section
* site: the address of the relocation (using the loaded memory address) [= section address + offset]
* target: the target of the relocation
* value: the value currently in site (4 bytes)
* adjusted value: the value to copied into site (calculation depends on type)

For ADDR32 / ADDR64, the adjusted value is simple, its just the target address + the value.  For REL32, the adjusted value is the target address - (site address + 4).

| section | offset | site | target | kind | value | adjusted value |
| --- | --- | --- | --- | --- | --- | --- |
| ape.text | 13 | 0xc91f00d | ape.data | ADDR32 | 0x4 | 0xc91f054 |
| ape.text | 18 | 0xc91f012 | _chisel | REL32 | 0x0 | 0xB |
| insect.text | 5 | 0xc91f025 | insect.data | ADDR32 | 0x8 | 0xc91f078 |
| insect.text | 13 | 0xc91f02d | bicycle | ADDR32 | 0x0 | 0xc91f062 |
| insect.text | 23 | 0xc91f037 | bicycle | ADDR32 | 0x0 | 0xc91f062 |
| insect.text | 31 | 0xc91f03f | insect.data | ADDR32 | 0x0 | 0xc91f070 |
| insect.data | 8 | 0xc91f078 | _saw | ADDR64 | 0x0 | 0xc91f005 |

Finally, we have enough to generate the final image.

### Final Image Generation

First, concatenate all of the sections together (in the right order with padding):

``` asm
00000000: CC CC CC CC CC 55 48 89  E5 48 8B 0C 25 04 00 00
00000010: 00 E8 00 00 00 00 5D C3  00 00 00 00 00 00 00 00
00000020: CC 48 8B 04 25 08 00 00  00 48 33 04 25 00 00 00
00000030: 00 C3 CC 48 8B 04 25 00  00 00 00 48 03 04 25 00
00000040: 00 00 00 C3 00 00 00 00  00 00 00 00 00 00 00 00
00000050: 00 00 00 00 71 02 00 00  00 00 00 00 00 00 00 00
00000060: 00 00 C2 01 00 00 00 00  00 00 00 00 00 00 00 00
00000070: 07 03 00 00 00 00 00 00  05 F0 91 0C 00 00 00 00
```

Now, for each entry in the relocation table, enter the adjusted value into the site address (in little endian).

``` asm
00000000: CC CC CC CC CC 55 48 89  E5 48 8B 0C 25 54 F0 91
00000010: 0C E8 0B 00 00 00 5D C3  00 00 00 00 00 00 00 00
00000020: CC 48 8B 04 25 78 F0 91  0C 48 33 04 25 62 F0 91
00000030: 0C C3 CC 48 8B 04 25 62  F0 91 0C 48 03 04 25 70
00000040: F0 91 0C C3 00 00 00 00  00 00 00 00 00 00 00 00
00000050: 00 00 00 00 71 02 00 00  00 00 00 00 00 00 00 00
00000060: 00 00 C2 01 00 00 00 00  00 00 00 00 00 00 00 00
00000070: 07 03 00 00 00 00 00 00  00 00 00 00 00 00 00 00
```

Now, we just simply load this file into a hex editor and check its md5 sum using [Online MD5](http://onlinemd5.com).
